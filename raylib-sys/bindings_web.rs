/* automatically generated by rust-bindgen */

pub const __GNUC_VA_LIST: u32 = 1;
pub const PI: f64 = 3.141592653589793;
pub const DEG2RAD: f64 = 0.017453292519943295;
pub const RAD2DEG: f64 = 57.29577951308232;
pub const MAX_TOUCH_POINTS: u32 = 10;
pub const MAX_SHADER_LOCATIONS: u32 = 32;
pub const MAX_MATERIAL_MAPS: u32 = 12;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vector2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_Vector2() {
    assert_eq!(
        ::std::mem::size_of::<Vector2>(),
        8usize,
        concat!("Size of: ", stringify!(Vector2))
    );
    assert_eq!(
        ::std::mem::align_of::<Vector2>(),
        4usize,
        concat!("Alignment of ", stringify!(Vector2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector2>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_Vector3() {
    assert_eq!(
        ::std::mem::size_of::<Vector3>(),
        12usize,
        concat!("Size of: ", stringify!(Vector3))
    );
    assert_eq!(
        ::std::mem::align_of::<Vector3>(),
        4usize,
        concat!("Alignment of ", stringify!(Vector3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector3>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector3>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vector4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_Vector4() {
    assert_eq!(
        ::std::mem::size_of::<Vector4>(),
        16usize,
        concat!("Size of: ", stringify!(Vector4))
    );
    assert_eq!(
        ::std::mem::align_of::<Vector4>(),
        4usize,
        concat!("Alignment of ", stringify!(Vector4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector4>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector4>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Vector4>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Vector4),
            "::",
            stringify!(w)
        )
    );
}
pub type Quaternion = Vector4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Matrix {
    pub m0: f32,
    pub m4: f32,
    pub m8: f32,
    pub m12: f32,
    pub m1: f32,
    pub m5: f32,
    pub m9: f32,
    pub m13: f32,
    pub m2: f32,
    pub m6: f32,
    pub m10: f32,
    pub m14: f32,
    pub m3: f32,
    pub m7: f32,
    pub m11: f32,
    pub m15: f32,
}
#[test]
fn bindgen_test_layout_Matrix() {
    assert_eq!(
        ::std::mem::size_of::<Matrix>(),
        64usize,
        concat!("Size of: ", stringify!(Matrix))
    );
    assert_eq!(
        ::std::mem::align_of::<Matrix>(),
        4usize,
        concat!("Alignment of ", stringify!(Matrix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m4 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m8 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m12 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m5 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m9 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m13 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m6 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m10 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m14 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m3 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m7 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m11 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Matrix>())).m15 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Matrix),
            "::",
            stringify!(m15)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Color {
    pub r: ::std::os::raw::c_uchar,
    pub g: ::std::os::raw::c_uchar,
    pub b: ::std::os::raw::c_uchar,
    pub a: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_Color() {
    assert_eq!(
        ::std::mem::size_of::<Color>(),
        4usize,
        concat!("Size of: ", stringify!(Color))
    );
    assert_eq!(
        ::std::mem::align_of::<Color>(),
        1usize,
        concat!("Alignment of ", stringify!(Color))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Color>())).r as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Color), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Color>())).g as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(Color), "::", stringify!(g))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Color>())).b as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(Color), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Color>())).a as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(Color), "::", stringify!(a))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rectangle {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_Rectangle() {
    assert_eq!(
        ::std::mem::size_of::<Rectangle>(),
        16usize,
        concat!("Size of: ", stringify!(Rectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<Rectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(Rectangle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rectangle>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rectangle>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rectangle>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rectangle>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Rectangle),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image {
    pub data: *mut ::std::os::raw::c_void,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub mipmaps: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Image() {
    assert_eq!(
        ::std::mem::size_of::<Image>(),
        24usize,
        concat!("Size of: ", stringify!(Image))
    );
    assert_eq!(
        ::std::mem::align_of::<Image>(),
        8usize,
        concat!("Alignment of ", stringify!(Image))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Image>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Image>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Image>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Image>())).mipmaps as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(mipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Image>())).format as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Image),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture2D {
    pub id: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub mipmaps: ::std::os::raw::c_int,
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Texture2D() {
    assert_eq!(
        ::std::mem::size_of::<Texture2D>(),
        20usize,
        concat!("Size of: ", stringify!(Texture2D))
    );
    assert_eq!(
        ::std::mem::align_of::<Texture2D>(),
        4usize,
        concat!("Alignment of ", stringify!(Texture2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Texture2D>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Texture2D),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Texture2D>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Texture2D),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Texture2D>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Texture2D),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Texture2D>())).mipmaps as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Texture2D),
            "::",
            stringify!(mipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Texture2D>())).format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Texture2D),
            "::",
            stringify!(format)
        )
    );
}
pub type Texture = Texture2D;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RenderTexture2D {
    pub id: ::std::os::raw::c_uint,
    pub texture: Texture2D,
    pub depth: Texture2D,
}
#[test]
fn bindgen_test_layout_RenderTexture2D() {
    assert_eq!(
        ::std::mem::size_of::<RenderTexture2D>(),
        44usize,
        concat!("Size of: ", stringify!(RenderTexture2D))
    );
    assert_eq!(
        ::std::mem::align_of::<RenderTexture2D>(),
        4usize,
        concat!("Alignment of ", stringify!(RenderTexture2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTexture2D>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTexture2D),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTexture2D>())).texture as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTexture2D),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RenderTexture2D>())).depth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RenderTexture2D),
            "::",
            stringify!(depth)
        )
    );
}
pub type RenderTexture = RenderTexture2D;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NPatchInfo {
    pub sourceRec: Rectangle,
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NPatchInfo() {
    assert_eq!(
        ::std::mem::size_of::<NPatchInfo>(),
        36usize,
        concat!("Size of: ", stringify!(NPatchInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NPatchInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(NPatchInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NPatchInfo>())).sourceRec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NPatchInfo),
            "::",
            stringify!(sourceRec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NPatchInfo>())).left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NPatchInfo),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NPatchInfo>())).top as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NPatchInfo),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NPatchInfo>())).right as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NPatchInfo),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NPatchInfo>())).bottom as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NPatchInfo),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NPatchInfo>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NPatchInfo),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CharInfo {
    pub value: ::std::os::raw::c_int,
    pub rec: Rectangle,
    pub offsetX: ::std::os::raw::c_int,
    pub offsetY: ::std::os::raw::c_int,
    pub advanceX: ::std::os::raw::c_int,
    pub data: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_CharInfo() {
    assert_eq!(
        ::std::mem::size_of::<CharInfo>(),
        40usize,
        concat!("Size of: ", stringify!(CharInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CharInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CharInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).rec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(rec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).offsetX as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(offsetX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).offsetY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(offsetY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).advanceX as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(advanceX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CharInfo>())).data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CharInfo),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Font {
    pub texture: Texture2D,
    pub baseSize: ::std::os::raw::c_int,
    pub charsCount: ::std::os::raw::c_int,
    pub chars: *mut CharInfo,
}
#[test]
fn bindgen_test_layout_Font() {
    assert_eq!(
        ::std::mem::size_of::<Font>(),
        40usize,
        concat!("Size of: ", stringify!(Font))
    );
    assert_eq!(
        ::std::mem::align_of::<Font>(),
        8usize,
        concat!("Alignment of ", stringify!(Font))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Font>())).texture as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Font),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Font>())).baseSize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Font),
            "::",
            stringify!(baseSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Font>())).charsCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Font),
            "::",
            stringify!(charsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Font>())).chars as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Font),
            "::",
            stringify!(chars)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Camera3D {
    pub position: Vector3,
    pub target: Vector3,
    pub up: Vector3,
    pub fovy: f32,
    pub type_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Camera3D() {
    assert_eq!(
        ::std::mem::size_of::<Camera3D>(),
        44usize,
        concat!("Size of: ", stringify!(Camera3D))
    );
    assert_eq!(
        ::std::mem::align_of::<Camera3D>(),
        4usize,
        concat!("Alignment of ", stringify!(Camera3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera3D>())).position as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera3D),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera3D>())).target as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera3D),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera3D>())).up as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera3D),
            "::",
            stringify!(up)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera3D>())).fovy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera3D),
            "::",
            stringify!(fovy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera3D>())).type_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera3D),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Camera2D {
    pub offset: Vector2,
    pub target: Vector2,
    pub rotation: f32,
    pub zoom: f32,
}
#[test]
fn bindgen_test_layout_Camera2D() {
    assert_eq!(
        ::std::mem::size_of::<Camera2D>(),
        24usize,
        concat!("Size of: ", stringify!(Camera2D))
    );
    assert_eq!(
        ::std::mem::align_of::<Camera2D>(),
        4usize,
        concat!("Alignment of ", stringify!(Camera2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera2D>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera2D),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera2D>())).target as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera2D),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera2D>())).rotation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera2D),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Camera2D>())).zoom as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Camera2D),
            "::",
            stringify!(zoom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BoundingBox {
    pub min: Vector3,
    pub max: Vector3,
}
#[test]
fn bindgen_test_layout_BoundingBox() {
    assert_eq!(
        ::std::mem::size_of::<BoundingBox>(),
        24usize,
        concat!("Size of: ", stringify!(BoundingBox))
    );
    assert_eq!(
        ::std::mem::align_of::<BoundingBox>(),
        4usize,
        concat!("Alignment of ", stringify!(BoundingBox))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BoundingBox>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BoundingBox),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BoundingBox>())).max as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BoundingBox),
            "::",
            stringify!(max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mesh {
    pub vertexCount: ::std::os::raw::c_int,
    pub triangleCount: ::std::os::raw::c_int,
    pub vertices: *mut f32,
    pub texcoords: *mut f32,
    pub texcoords2: *mut f32,
    pub normals: *mut f32,
    pub tangents: *mut f32,
    pub colors: *mut ::std::os::raw::c_uchar,
    pub indices: *mut ::std::os::raw::c_ushort,
    pub baseVertices: *mut f32,
    pub baseNormals: *mut f32,
    pub weightBias: *mut f32,
    pub weightId: *mut ::std::os::raw::c_int,
    pub vaoId: ::std::os::raw::c_uint,
    pub vboId: [::std::os::raw::c_uint; 7usize],
}
#[test]
fn bindgen_test_layout_Mesh() {
    assert_eq!(
        ::std::mem::size_of::<Mesh>(),
        128usize,
        concat!("Size of: ", stringify!(Mesh))
    );
    assert_eq!(
        ::std::mem::align_of::<Mesh>(),
        8usize,
        concat!("Alignment of ", stringify!(Mesh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).vertexCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(vertexCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).triangleCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(triangleCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).vertices as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(vertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).texcoords as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(texcoords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).texcoords2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(texcoords2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).normals as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(normals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).tangents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(tangents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).colors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).indices as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(indices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).baseVertices as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(baseVertices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).baseNormals as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(baseNormals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).weightBias as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(weightBias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).weightId as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(weightId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).vaoId as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(vaoId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).vboId as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(vboId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Shader {
    pub id: ::std::os::raw::c_uint,
    pub locs: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_Shader() {
    assert_eq!(
        ::std::mem::size_of::<Shader>(),
        132usize,
        concat!("Size of: ", stringify!(Shader))
    );
    assert_eq!(
        ::std::mem::align_of::<Shader>(),
        4usize,
        concat!("Alignment of ", stringify!(Shader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Shader>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Shader),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Shader>())).locs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Shader),
            "::",
            stringify!(locs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaterialMap {
    pub texture: Texture2D,
    pub color: Color,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_MaterialMap() {
    assert_eq!(
        ::std::mem::size_of::<MaterialMap>(),
        28usize,
        concat!("Size of: ", stringify!(MaterialMap))
    );
    assert_eq!(
        ::std::mem::align_of::<MaterialMap>(),
        4usize,
        concat!("Alignment of ", stringify!(MaterialMap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MaterialMap>())).texture as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MaterialMap),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MaterialMap>())).color as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MaterialMap),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MaterialMap>())).value as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MaterialMap),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Material {
    pub shader: Shader,
    pub maps: [MaterialMap; 12usize],
    pub params: *mut f32,
}
#[test]
fn bindgen_test_layout_Material() {
    assert_eq!(
        ::std::mem::size_of::<Material>(),
        480usize,
        concat!("Size of: ", stringify!(Material))
    );
    assert_eq!(
        ::std::mem::align_of::<Material>(),
        8usize,
        concat!("Alignment of ", stringify!(Material))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Material>())).shader as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Material),
            "::",
            stringify!(shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Material>())).maps as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(Material),
            "::",
            stringify!(maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Material>())).params as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(Material),
            "::",
            stringify!(params)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Model {
    pub mesh: Mesh,
    pub transform: Matrix,
    pub material: Material,
}
#[test]
fn bindgen_test_layout_Model() {
    assert_eq!(
        ::std::mem::size_of::<Model>(),
        672usize,
        concat!("Size of: ", stringify!(Model))
    );
    assert_eq!(
        ::std::mem::align_of::<Model>(),
        8usize,
        concat!("Alignment of ", stringify!(Model))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Model>())).mesh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Model),
            "::",
            stringify!(mesh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Model>())).transform as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Model),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Model>())).material as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Model),
            "::",
            stringify!(material)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ray {
    pub position: Vector3,
    pub direction: Vector3,
}
#[test]
fn bindgen_test_layout_Ray() {
    assert_eq!(
        ::std::mem::size_of::<Ray>(),
        24usize,
        concat!("Size of: ", stringify!(Ray))
    );
    assert_eq!(
        ::std::mem::align_of::<Ray>(),
        4usize,
        concat!("Alignment of ", stringify!(Ray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ray>())).position as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Ray),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ray>())).direction as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Ray),
            "::",
            stringify!(direction)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayHitInfo {
    pub hit: bool,
    pub distance: f32,
    pub position: Vector3,
    pub normal: Vector3,
}
#[test]
fn bindgen_test_layout_RayHitInfo() {
    assert_eq!(
        ::std::mem::size_of::<RayHitInfo>(),
        32usize,
        concat!("Size of: ", stringify!(RayHitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<RayHitInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(RayHitInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RayHitInfo>())).hit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RayHitInfo),
            "::",
            stringify!(hit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RayHitInfo>())).distance as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RayHitInfo),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RayHitInfo>())).position as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RayHitInfo),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RayHitInfo>())).normal as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RayHitInfo),
            "::",
            stringify!(normal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Wave {
    pub sampleCount: ::std::os::raw::c_uint,
    pub sampleRate: ::std::os::raw::c_uint,
    pub sampleSize: ::std::os::raw::c_uint,
    pub channels: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Wave() {
    assert_eq!(
        ::std::mem::size_of::<Wave>(),
        24usize,
        concat!("Size of: ", stringify!(Wave))
    );
    assert_eq!(
        ::std::mem::align_of::<Wave>(),
        8usize,
        concat!("Alignment of ", stringify!(Wave))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Wave>())).sampleCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Wave),
            "::",
            stringify!(sampleCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Wave>())).sampleRate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Wave),
            "::",
            stringify!(sampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Wave>())).sampleSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Wave),
            "::",
            stringify!(sampleSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Wave>())).channels as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Wave),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Wave>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Wave),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sound {
    pub audioBuffer: *mut ::std::os::raw::c_void,
    pub source: ::std::os::raw::c_uint,
    pub buffer: ::std::os::raw::c_uint,
    pub format: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Sound() {
    assert_eq!(
        ::std::mem::size_of::<Sound>(),
        24usize,
        concat!("Size of: ", stringify!(Sound))
    );
    assert_eq!(
        ::std::mem::align_of::<Sound>(),
        8usize,
        concat!("Alignment of ", stringify!(Sound))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sound>())).audioBuffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sound),
            "::",
            stringify!(audioBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sound>())).source as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sound),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sound>())).buffer as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Sound),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sound>())).format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Sound),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MusicData {
    _unused: [u8; 0],
}
pub type Music = *mut MusicData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AudioStream {
    pub sampleRate: ::std::os::raw::c_uint,
    pub sampleSize: ::std::os::raw::c_uint,
    pub channels: ::std::os::raw::c_uint,
    pub audioBuffer: *mut ::std::os::raw::c_void,
    pub format: ::std::os::raw::c_int,
    pub source: ::std::os::raw::c_uint,
    pub buffers: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout_AudioStream() {
    assert_eq!(
        ::std::mem::size_of::<AudioStream>(),
        40usize,
        concat!("Size of: ", stringify!(AudioStream))
    );
    assert_eq!(
        ::std::mem::align_of::<AudioStream>(),
        8usize,
        concat!("Alignment of ", stringify!(AudioStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).sampleRate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(sampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).sampleSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(sampleSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).channels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).audioBuffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(audioBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).source as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AudioStream>())).buffers as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AudioStream),
            "::",
            stringify!(buffers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VrDeviceInfo {
    pub hResolution: ::std::os::raw::c_int,
    pub vResolution: ::std::os::raw::c_int,
    pub hScreenSize: f32,
    pub vScreenSize: f32,
    pub vScreenCenter: f32,
    pub eyeToScreenDistance: f32,
    pub lensSeparationDistance: f32,
    pub interpupillaryDistance: f32,
    pub lensDistortionValues: [f32; 4usize],
    pub chromaAbCorrection: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_VrDeviceInfo() {
    assert_eq!(
        ::std::mem::size_of::<VrDeviceInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VrDeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VrDeviceInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(VrDeviceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).hResolution as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(hResolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).vResolution as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(vResolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).hScreenSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(hScreenSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).vScreenSize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(vScreenSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).vScreenCenter as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(vScreenCenter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VrDeviceInfo>())).eyeToScreenDistance as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(eyeToScreenDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VrDeviceInfo>())).lensSeparationDistance as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(lensSeparationDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VrDeviceInfo>())).interpupillaryDistance as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(interpupillaryDistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VrDeviceInfo>())).lensDistortionValues as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(lensDistortionValues)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VrDeviceInfo>())).chromaAbCorrection as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VrDeviceInfo),
            "::",
            stringify!(chromaAbCorrection)
        )
    );
}
pub mod ConfigFlag {
    pub type Type = u32;
    pub const FLAG_SHOW_LOGO: Type = 1;
    pub const FLAG_FULLSCREEN_MODE: Type = 2;
    pub const FLAG_WINDOW_RESIZABLE: Type = 4;
    pub const FLAG_WINDOW_UNDECORATED: Type = 8;
    pub const FLAG_WINDOW_TRANSPARENT: Type = 16;
    pub const FLAG_WINDOW_HIDDEN: Type = 128;
    pub const FLAG_MSAA_4X_HINT: Type = 32;
    pub const FLAG_VSYNC_HINT: Type = 64;
}
pub mod TraceLogType {
    pub type Type = u32;
    pub const LOG_INFO: Type = 1;
    pub const LOG_WARNING: Type = 2;
    pub const LOG_ERROR: Type = 4;
    pub const LOG_DEBUG: Type = 8;
    pub const LOG_OTHER: Type = 16;
}
pub mod KeyboardKey {
    pub type Type = u32;
    pub const KEY_APOSTROPHE: Type = 39;
    pub const KEY_COMMA: Type = 44;
    pub const KEY_MINUS: Type = 45;
    pub const KEY_PERIOD: Type = 46;
    pub const KEY_SLASH: Type = 47;
    pub const KEY_ZERO: Type = 48;
    pub const KEY_ONE: Type = 49;
    pub const KEY_TWO: Type = 50;
    pub const KEY_THREE: Type = 51;
    pub const KEY_FOUR: Type = 52;
    pub const KEY_FIVE: Type = 53;
    pub const KEY_SIX: Type = 54;
    pub const KEY_SEVEN: Type = 55;
    pub const KEY_EIGHT: Type = 56;
    pub const KEY_NINE: Type = 57;
    pub const KEY_SEMICOLON: Type = 59;
    pub const KEY_EQUAL: Type = 61;
    pub const KEY_A: Type = 65;
    pub const KEY_B: Type = 66;
    pub const KEY_C: Type = 67;
    pub const KEY_D: Type = 68;
    pub const KEY_E: Type = 69;
    pub const KEY_F: Type = 70;
    pub const KEY_G: Type = 71;
    pub const KEY_H: Type = 72;
    pub const KEY_I: Type = 73;
    pub const KEY_J: Type = 74;
    pub const KEY_K: Type = 75;
    pub const KEY_L: Type = 76;
    pub const KEY_M: Type = 77;
    pub const KEY_N: Type = 78;
    pub const KEY_O: Type = 79;
    pub const KEY_P: Type = 80;
    pub const KEY_Q: Type = 81;
    pub const KEY_R: Type = 82;
    pub const KEY_S: Type = 83;
    pub const KEY_T: Type = 84;
    pub const KEY_U: Type = 85;
    pub const KEY_V: Type = 86;
    pub const KEY_W: Type = 87;
    pub const KEY_X: Type = 88;
    pub const KEY_Y: Type = 89;
    pub const KEY_Z: Type = 90;
    pub const KEY_SPACE: Type = 32;
    pub const KEY_ESCAPE: Type = 256;
    pub const KEY_ENTER: Type = 257;
    pub const KEY_TAB: Type = 258;
    pub const KEY_BACKSPACE: Type = 259;
    pub const KEY_INSERT: Type = 260;
    pub const KEY_DELETE: Type = 261;
    pub const KEY_RIGHT: Type = 262;
    pub const KEY_LEFT: Type = 263;
    pub const KEY_DOWN: Type = 264;
    pub const KEY_UP: Type = 265;
    pub const KEY_PAGE_UP: Type = 266;
    pub const KEY_PAGE_DOWN: Type = 267;
    pub const KEY_HOME: Type = 268;
    pub const KEY_END: Type = 269;
    pub const KEY_CAPS_LOCK: Type = 280;
    pub const KEY_SCROLL_LOCK: Type = 281;
    pub const KEY_NUM_LOCK: Type = 282;
    pub const KEY_PRINT_SCREEN: Type = 283;
    pub const KEY_PAUSE: Type = 284;
    pub const KEY_F1: Type = 290;
    pub const KEY_F2: Type = 291;
    pub const KEY_F3: Type = 292;
    pub const KEY_F4: Type = 293;
    pub const KEY_F5: Type = 294;
    pub const KEY_F6: Type = 295;
    pub const KEY_F7: Type = 296;
    pub const KEY_F8: Type = 297;
    pub const KEY_F9: Type = 298;
    pub const KEY_F10: Type = 299;
    pub const KEY_F11: Type = 300;
    pub const KEY_F12: Type = 301;
    pub const KEY_LEFT_SHIFT: Type = 340;
    pub const KEY_LEFT_CONTROL: Type = 341;
    pub const KEY_LEFT_ALT: Type = 342;
    pub const KEY_LEFT_SUPER: Type = 343;
    pub const KEY_RIGHT_SHIFT: Type = 344;
    pub const KEY_RIGHT_CONTROL: Type = 345;
    pub const KEY_RIGHT_ALT: Type = 346;
    pub const KEY_RIGHT_SUPER: Type = 347;
    pub const KEY_KB_MENU: Type = 348;
    pub const KEY_LEFT_BRACKET: Type = 91;
    pub const KEY_BACKSLASH: Type = 92;
    pub const KEY_RIGHT_BRACKET: Type = 93;
    pub const KEY_GRAVE: Type = 96;
    pub const KEY_KP_0: Type = 320;
    pub const KEY_KP_1: Type = 321;
    pub const KEY_KP_2: Type = 322;
    pub const KEY_KP_3: Type = 323;
    pub const KEY_KP_4: Type = 324;
    pub const KEY_KP_5: Type = 325;
    pub const KEY_KP_6: Type = 326;
    pub const KEY_KP_7: Type = 327;
    pub const KEY_KP_8: Type = 328;
    pub const KEY_KP_9: Type = 329;
    pub const KEY_KP_DECIMAL: Type = 330;
    pub const KEY_KP_DIVIDE: Type = 331;
    pub const KEY_KP_MULTIPLY: Type = 332;
    pub const KEY_KP_SUBTRACT: Type = 333;
    pub const KEY_KP_ADD: Type = 334;
    pub const KEY_KP_ENTER: Type = 335;
    pub const KEY_KP_EQUAL: Type = 336;
}
pub mod AndroidButton {
    pub type Type = u32;
    pub const KEY_BACK: Type = 4;
    pub const KEY_MENU: Type = 82;
    pub const KEY_VOLUME_UP: Type = 24;
    pub const KEY_VOLUME_DOWN: Type = 25;
}
pub mod MouseButton {
    pub type Type = u32;
    pub const MOUSE_LEFT_BUTTON: Type = 0;
    pub const MOUSE_RIGHT_BUTTON: Type = 1;
    pub const MOUSE_MIDDLE_BUTTON: Type = 2;
}
pub mod GamepadNumber {
    pub type Type = u32;
    pub const GAMEPAD_PLAYER1: Type = 0;
    pub const GAMEPAD_PLAYER2: Type = 1;
    pub const GAMEPAD_PLAYER3: Type = 2;
    pub const GAMEPAD_PLAYER4: Type = 3;
}
pub mod GamepadPS3Button {
    pub type Type = u32;
    pub const GAMEPAD_PS3_BUTTON_TRIANGLE: Type = 0;
    pub const GAMEPAD_PS3_BUTTON_CIRCLE: Type = 1;
    pub const GAMEPAD_PS3_BUTTON_CROSS: Type = 2;
    pub const GAMEPAD_PS3_BUTTON_SQUARE: Type = 3;
    pub const GAMEPAD_PS3_BUTTON_L1: Type = 6;
    pub const GAMEPAD_PS3_BUTTON_R1: Type = 7;
    pub const GAMEPAD_PS3_BUTTON_L2: Type = 4;
    pub const GAMEPAD_PS3_BUTTON_R2: Type = 5;
    pub const GAMEPAD_PS3_BUTTON_START: Type = 8;
    pub const GAMEPAD_PS3_BUTTON_SELECT: Type = 9;
    pub const GAMEPAD_PS3_BUTTON_PS: Type = 12;
    pub const GAMEPAD_PS3_BUTTON_UP: Type = 24;
    pub const GAMEPAD_PS3_BUTTON_RIGHT: Type = 25;
    pub const GAMEPAD_PS3_BUTTON_DOWN: Type = 26;
    pub const GAMEPAD_PS3_BUTTON_LEFT: Type = 27;
}
pub mod GamepadPS3Axis {
    pub type Type = u32;
    pub const GAMEPAD_PS3_AXIS_LEFT_X: Type = 0;
    pub const GAMEPAD_PS3_AXIS_LEFT_Y: Type = 1;
    pub const GAMEPAD_PS3_AXIS_RIGHT_X: Type = 2;
    pub const GAMEPAD_PS3_AXIS_RIGHT_Y: Type = 5;
    pub const GAMEPAD_PS3_AXIS_L2: Type = 3;
    pub const GAMEPAD_PS3_AXIS_R2: Type = 4;
}
pub mod GamepadXbox360Button {
    pub type Type = u32;
    pub const GAMEPAD_XBOX_BUTTON_A: Type = 0;
    pub const GAMEPAD_XBOX_BUTTON_B: Type = 1;
    pub const GAMEPAD_XBOX_BUTTON_X: Type = 2;
    pub const GAMEPAD_XBOX_BUTTON_Y: Type = 3;
    pub const GAMEPAD_XBOX_BUTTON_LB: Type = 4;
    pub const GAMEPAD_XBOX_BUTTON_RB: Type = 5;
    pub const GAMEPAD_XBOX_BUTTON_SELECT: Type = 6;
    pub const GAMEPAD_XBOX_BUTTON_START: Type = 7;
    pub const GAMEPAD_XBOX_BUTTON_HOME: Type = 8;
    pub const GAMEPAD_XBOX_BUTTON_UP: Type = 10;
    pub const GAMEPAD_XBOX_BUTTON_RIGHT: Type = 11;
    pub const GAMEPAD_XBOX_BUTTON_DOWN: Type = 12;
    pub const GAMEPAD_XBOX_BUTTON_LEFT: Type = 13;
}
pub mod GamepadXbox360Axis {
    pub type Type = u32;
    pub const GAMEPAD_XBOX_AXIS_LEFT_X: Type = 0;
    pub const GAMEPAD_XBOX_AXIS_LEFT_Y: Type = 1;
    pub const GAMEPAD_XBOX_AXIS_RIGHT_X: Type = 2;
    pub const GAMEPAD_XBOX_AXIS_RIGHT_Y: Type = 3;
    pub const GAMEPAD_XBOX_AXIS_LT: Type = 4;
    pub const GAMEPAD_XBOX_AXIS_RT: Type = 5;
}
pub mod GamepadAndroid {
    pub type Type = u32;
    pub const GAMEPAD_ANDROID_DPAD_UP: Type = 19;
    pub const GAMEPAD_ANDROID_DPAD_DOWN: Type = 20;
    pub const GAMEPAD_ANDROID_DPAD_LEFT: Type = 21;
    pub const GAMEPAD_ANDROID_DPAD_RIGHT: Type = 22;
    pub const GAMEPAD_ANDROID_DPAD_CENTER: Type = 23;
    pub const GAMEPAD_ANDROID_BUTTON_A: Type = 96;
    pub const GAMEPAD_ANDROID_BUTTON_B: Type = 97;
    pub const GAMEPAD_ANDROID_BUTTON_C: Type = 98;
    pub const GAMEPAD_ANDROID_BUTTON_X: Type = 99;
    pub const GAMEPAD_ANDROID_BUTTON_Y: Type = 100;
    pub const GAMEPAD_ANDROID_BUTTON_Z: Type = 101;
    pub const GAMEPAD_ANDROID_BUTTON_L1: Type = 102;
    pub const GAMEPAD_ANDROID_BUTTON_R1: Type = 103;
    pub const GAMEPAD_ANDROID_BUTTON_L2: Type = 104;
    pub const GAMEPAD_ANDROID_BUTTON_R2: Type = 105;
}
pub mod ShaderLocationIndex {
    pub type Type = u32;
    pub const LOC_VERTEX_POSITION: Type = 0;
    pub const LOC_VERTEX_TEXCOORD01: Type = 1;
    pub const LOC_VERTEX_TEXCOORD02: Type = 2;
    pub const LOC_VERTEX_NORMAL: Type = 3;
    pub const LOC_VERTEX_TANGENT: Type = 4;
    pub const LOC_VERTEX_COLOR: Type = 5;
    pub const LOC_MATRIX_MVP: Type = 6;
    pub const LOC_MATRIX_MODEL: Type = 7;
    pub const LOC_MATRIX_VIEW: Type = 8;
    pub const LOC_MATRIX_PROJECTION: Type = 9;
    pub const LOC_VECTOR_VIEW: Type = 10;
    pub const LOC_COLOR_DIFFUSE: Type = 11;
    pub const LOC_COLOR_SPECULAR: Type = 12;
    pub const LOC_COLOR_AMBIENT: Type = 13;
    pub const LOC_MAP_ALBEDO: Type = 14;
    pub const LOC_MAP_METALNESS: Type = 15;
    pub const LOC_MAP_NORMAL: Type = 16;
    pub const LOC_MAP_ROUGHNESS: Type = 17;
    pub const LOC_MAP_OCCLUSION: Type = 18;
    pub const LOC_MAP_EMISSION: Type = 19;
    pub const LOC_MAP_HEIGHT: Type = 20;
    pub const LOC_MAP_CUBEMAP: Type = 21;
    pub const LOC_MAP_IRRADIANCE: Type = 22;
    pub const LOC_MAP_PREFILTER: Type = 23;
    pub const LOC_MAP_BRDF: Type = 24;
}
pub mod ShaderUniformDataType {
    pub type Type = u32;
    pub const UNIFORM_FLOAT: Type = 0;
    pub const UNIFORM_VEC2: Type = 1;
    pub const UNIFORM_VEC3: Type = 2;
    pub const UNIFORM_VEC4: Type = 3;
    pub const UNIFORM_INT: Type = 4;
    pub const UNIFORM_IVEC2: Type = 5;
    pub const UNIFORM_IVEC3: Type = 6;
    pub const UNIFORM_IVEC4: Type = 7;
    pub const UNIFORM_SAMPLER2D: Type = 8;
}
pub mod TexmapIndex {
    pub type Type = u32;
    pub const MAP_ALBEDO: Type = 0;
    pub const MAP_METALNESS: Type = 1;
    pub const MAP_NORMAL: Type = 2;
    pub const MAP_ROUGHNESS: Type = 3;
    pub const MAP_OCCLUSION: Type = 4;
    pub const MAP_EMISSION: Type = 5;
    pub const MAP_HEIGHT: Type = 6;
    pub const MAP_CUBEMAP: Type = 7;
    pub const MAP_IRRADIANCE: Type = 8;
    pub const MAP_PREFILTER: Type = 9;
    pub const MAP_BRDF: Type = 10;
}
pub mod PixelFormat {
    pub type Type = u32;
    pub const UNCOMPRESSED_GRAYSCALE: Type = 1;
    pub const UNCOMPRESSED_GRAY_ALPHA: Type = 2;
    pub const UNCOMPRESSED_R5G6B5: Type = 3;
    pub const UNCOMPRESSED_R8G8B8: Type = 4;
    pub const UNCOMPRESSED_R5G5B5A1: Type = 5;
    pub const UNCOMPRESSED_R4G4B4A4: Type = 6;
    pub const UNCOMPRESSED_R8G8B8A8: Type = 7;
    pub const UNCOMPRESSED_R32: Type = 8;
    pub const UNCOMPRESSED_R32G32B32: Type = 9;
    pub const UNCOMPRESSED_R32G32B32A32: Type = 10;
    pub const COMPRESSED_DXT1_RGB: Type = 11;
    pub const COMPRESSED_DXT1_RGBA: Type = 12;
    pub const COMPRESSED_DXT3_RGBA: Type = 13;
    pub const COMPRESSED_DXT5_RGBA: Type = 14;
    pub const COMPRESSED_ETC1_RGB: Type = 15;
    pub const COMPRESSED_ETC2_RGB: Type = 16;
    pub const COMPRESSED_ETC2_EAC_RGBA: Type = 17;
    pub const COMPRESSED_PVRT_RGB: Type = 18;
    pub const COMPRESSED_PVRT_RGBA: Type = 19;
    pub const COMPRESSED_ASTC_4x4_RGBA: Type = 20;
    pub const COMPRESSED_ASTC_8x8_RGBA: Type = 21;
}
pub mod TextureFilterMode {
    pub type Type = u32;
    pub const FILTER_POINT: Type = 0;
    pub const FILTER_BILINEAR: Type = 1;
    pub const FILTER_TRILINEAR: Type = 2;
    pub const FILTER_ANISOTROPIC_4X: Type = 3;
    pub const FILTER_ANISOTROPIC_8X: Type = 4;
    pub const FILTER_ANISOTROPIC_16X: Type = 5;
}
pub mod TextureWrapMode {
    pub type Type = u32;
    pub const WRAP_REPEAT: Type = 0;
    pub const WRAP_CLAMP: Type = 1;
    pub const WRAP_MIRROR_REPEAT: Type = 2;
    pub const WRAP_MIRROR_CLAMP: Type = 3;
}
pub mod FontType {
    pub type Type = u32;
    pub const FONT_DEFAULT: Type = 0;
    pub const FONT_BITMAP: Type = 1;
    pub const FONT_SDF: Type = 2;
}
pub mod BlendMode {
    pub type Type = u32;
    pub const BLEND_ALPHA: Type = 0;
    pub const BLEND_ADDITIVE: Type = 1;
    pub const BLEND_MULTIPLIED: Type = 2;
}
pub mod GestureType {
    pub type Type = u32;
    pub const GESTURE_NONE: Type = 0;
    pub const GESTURE_TAP: Type = 1;
    pub const GESTURE_DOUBLETAP: Type = 2;
    pub const GESTURE_HOLD: Type = 4;
    pub const GESTURE_DRAG: Type = 8;
    pub const GESTURE_SWIPE_RIGHT: Type = 16;
    pub const GESTURE_SWIPE_LEFT: Type = 32;
    pub const GESTURE_SWIPE_UP: Type = 64;
    pub const GESTURE_SWIPE_DOWN: Type = 128;
    pub const GESTURE_PINCH_IN: Type = 256;
    pub const GESTURE_PINCH_OUT: Type = 512;
}
pub mod CameraMode {
    pub type Type = u32;
    pub const CAMERA_CUSTOM: Type = 0;
    pub const CAMERA_FREE: Type = 1;
    pub const CAMERA_ORBITAL: Type = 2;
    pub const CAMERA_FIRST_PERSON: Type = 3;
    pub const CAMERA_THIRD_PERSON: Type = 4;
}
pub mod CameraType {
    pub type Type = u32;
    pub const CAMERA_PERSPECTIVE: Type = 0;
    pub const CAMERA_ORTHOGRAPHIC: Type = 1;
}
pub mod VrDeviceType {
    pub type Type = u32;
    pub const HMD_DEFAULT_DEVICE: Type = 0;
    pub const HMD_OCULUS_RIFT_DK2: Type = 1;
    pub const HMD_OCULUS_RIFT_CV1: Type = 2;
    pub const HMD_OCULUS_GO: Type = 3;
    pub const HMD_VALVE_HTC_VIVE: Type = 4;
    pub const HMD_SONY_PSVR: Type = 5;
}
pub mod NPatchType {
    pub type Type = u32;
    pub const NPT_9PATCH: Type = 0;
    pub const NPT_3PATCH_VERTICAL: Type = 1;
    pub const NPT_3PATCH_HORIZONTAL: Type = 2;
}
pub type TraceLogCallback = ::std::option::Option<
    unsafe extern "C" fn(
        msgType: ::std::os::raw::c_int,
        text: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ),
>;
extern "C" {
    #[link_name = "InitWindow"]
    pub fn InitWindow(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        title: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "WindowShouldClose"]
    pub fn WindowShouldClose() -> bool;
}
extern "C" {
    #[link_name = "CloseWindow"]
    pub fn CloseWindow();
}
extern "C" {
    #[link_name = "IsWindowReady"]
    pub fn IsWindowReady() -> bool;
}
extern "C" {
    #[link_name = "IsWindowMinimized"]
    pub fn IsWindowMinimized() -> bool;
}
extern "C" {
    #[link_name = "IsWindowHidden"]
    pub fn IsWindowHidden() -> bool;
}
extern "C" {
    #[link_name = "ToggleFullscreen"]
    pub fn ToggleFullscreen();
}
extern "C" {
    #[link_name = "UnhideWindow"]
    pub fn UnhideWindow();
}
extern "C" {
    #[link_name = "HideWindow"]
    pub fn HideWindow();
}
extern "C" {
    #[link_name = "SetWindowIcon"]
    pub fn SetWindowIcon(image: Image);
}
extern "C" {
    #[link_name = "SetWindowTitle"]
    pub fn SetWindowTitle(title: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "SetWindowPosition"]
    pub fn SetWindowPosition(x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "SetWindowMonitor"]
    pub fn SetWindowMonitor(monitor: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "SetWindowMinSize"]
    pub fn SetWindowMinSize(width: ::std::os::raw::c_int, height: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "SetWindowSize"]
    pub fn SetWindowSize(width: ::std::os::raw::c_int, height: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "GetWindowHandle"]
    pub fn GetWindowHandle() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "GetScreenWidth"]
    pub fn GetScreenWidth() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetScreenHeight"]
    pub fn GetScreenHeight() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetMonitorCount"]
    pub fn GetMonitorCount() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetMonitorWidth"]
    pub fn GetMonitorWidth(monitor: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetMonitorHeight"]
    pub fn GetMonitorHeight(monitor: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetMonitorPhysicalWidth"]
    pub fn GetMonitorPhysicalWidth(monitor: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetMonitorPhysicalHeight"]
    pub fn GetMonitorPhysicalHeight(monitor: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetMonitorName"]
    pub fn GetMonitorName(monitor: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "ShowCursor"]
    pub fn ShowCursor();
}
extern "C" {
    #[link_name = "HideCursor"]
    pub fn HideCursor();
}
extern "C" {
    #[link_name = "IsCursorHidden"]
    pub fn IsCursorHidden() -> bool;
}
extern "C" {
    #[link_name = "EnableCursor"]
    pub fn EnableCursor();
}
extern "C" {
    #[link_name = "DisableCursor"]
    pub fn DisableCursor();
}
extern "C" {
    #[link_name = "ClearBackground"]
    pub fn ClearBackground(color: Color);
}
extern "C" {
    #[link_name = "BeginDrawing"]
    pub fn BeginDrawing();
}
extern "C" {
    #[link_name = "EndDrawing"]
    pub fn EndDrawing();
}
extern "C" {
    #[link_name = "BeginMode2D"]
    pub fn BeginMode2D(camera: Camera2D);
}
extern "C" {
    #[link_name = "EndMode2D"]
    pub fn EndMode2D();
}
extern "C" {
    #[link_name = "BeginMode3D"]
    pub fn BeginMode3D(camera: Camera3D);
}
extern "C" {
    #[link_name = "EndMode3D"]
    pub fn EndMode3D();
}
extern "C" {
    #[link_name = "BeginTextureMode"]
    pub fn BeginTextureMode(target: RenderTexture2D);
}
extern "C" {
    #[link_name = "EndTextureMode"]
    pub fn EndTextureMode();
}
extern "C" {
    #[link_name = "GetMouseRay"]
    pub fn GetMouseRay(mousePosition: Vector2, camera: Camera3D) -> Ray;
}
extern "C" {
    #[link_name = "GetWorldToScreen"]
    pub fn GetWorldToScreen(position: Vector3, camera: Camera3D) -> Vector2;
}
extern "C" {
    #[link_name = "GetCameraMatrix"]
    pub fn GetCameraMatrix(camera: Camera3D) -> Matrix;
}
extern "C" {
    #[link_name = "SetTargetFPS"]
    pub fn SetTargetFPS(fps: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "GetFPS"]
    pub fn GetFPS() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetFrameTime"]
    pub fn GetFrameTime() -> f32;
}
extern "C" {
    #[link_name = "GetTime"]
    pub fn GetTime() -> f64;
}
extern "C" {
    #[link_name = "ColorToInt"]
    pub fn ColorToInt(color: Color) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ColorNormalize"]
    pub fn ColorNormalize(color: Color) -> Vector4;
}
extern "C" {
    #[link_name = "ColorToHSV"]
    pub fn ColorToHSV(color: Color) -> Vector3;
}
extern "C" {
    #[link_name = "ColorFromHSV"]
    pub fn ColorFromHSV(hsv: Vector3) -> Color;
}
extern "C" {
    #[link_name = "GetColor"]
    pub fn GetColor(hexValue: ::std::os::raw::c_int) -> Color;
}
extern "C" {
    #[link_name = "Fade"]
    pub fn Fade(color: Color, alpha: f32) -> Color;
}
extern "C" {
    #[link_name = "SetConfigFlags"]
    pub fn SetConfigFlags(flags: ::std::os::raw::c_uchar);
}
extern "C" {
    #[link_name = "SetTraceLogLevel"]
    pub fn SetTraceLogLevel(types: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "SetTraceLogCallback"]
    pub fn SetTraceLogCallback(callback: TraceLogCallback);
}
extern "C" {
    #[link_name = "TraceLog"]
    pub fn TraceLog(logType: ::std::os::raw::c_int, text: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "TakeScreenshot"]
    pub fn TakeScreenshot(fileName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "GetRandomValue"]
    pub fn GetRandomValue(
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "FileExists"]
    pub fn FileExists(fileName: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "IsFileExtension"]
    pub fn IsFileExtension(
        fileName: *const ::std::os::raw::c_char,
        ext: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "GetExtension"]
    pub fn GetExtension(fileName: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "GetFileName"]
    pub fn GetFileName(filePath: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "GetFileNameWithoutExt"]
    pub fn GetFileNameWithoutExt(
        filePath: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "GetDirectoryPath"]
    pub fn GetDirectoryPath(
        fileName: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "GetWorkingDirectory"]
    pub fn GetWorkingDirectory() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "GetDirectoryFiles"]
    pub fn GetDirectoryFiles(
        dirPath: *const ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "ClearDirectoryFiles"]
    pub fn ClearDirectoryFiles();
}
extern "C" {
    #[link_name = "ChangeDirectory"]
    pub fn ChangeDirectory(dir: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "IsFileDropped"]
    pub fn IsFileDropped() -> bool;
}
extern "C" {
    #[link_name = "GetDroppedFiles"]
    pub fn GetDroppedFiles(count: *mut ::std::os::raw::c_int) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "ClearDroppedFiles"]
    pub fn ClearDroppedFiles();
}
extern "C" {
    #[link_name = "GetFileModTime"]
    pub fn GetFileModTime(fileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "StorageSaveValue"]
    pub fn StorageSaveValue(position: ::std::os::raw::c_int, value: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "StorageLoadValue"]
    pub fn StorageLoadValue(position: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "OpenURL"]
    pub fn OpenURL(url: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "IsKeyPressed"]
    pub fn IsKeyPressed(key: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "IsKeyDown"]
    pub fn IsKeyDown(key: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "IsKeyReleased"]
    pub fn IsKeyReleased(key: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "IsKeyUp"]
    pub fn IsKeyUp(key: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "GetKeyPressed"]
    pub fn GetKeyPressed() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "SetExitKey"]
    pub fn SetExitKey(key: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "IsGamepadAvailable"]
    pub fn IsGamepadAvailable(gamepad: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "IsGamepadName"]
    pub fn IsGamepadName(
        gamepad: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "GetGamepadName"]
    pub fn GetGamepadName(gamepad: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "IsGamepadButtonPressed"]
    pub fn IsGamepadButtonPressed(
        gamepad: ::std::os::raw::c_int,
        button: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "IsGamepadButtonDown"]
    pub fn IsGamepadButtonDown(
        gamepad: ::std::os::raw::c_int,
        button: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "IsGamepadButtonReleased"]
    pub fn IsGamepadButtonReleased(
        gamepad: ::std::os::raw::c_int,
        button: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "IsGamepadButtonUp"]
    pub fn IsGamepadButtonUp(gamepad: ::std::os::raw::c_int, button: ::std::os::raw::c_int)
        -> bool;
}
extern "C" {
    #[link_name = "GetGamepadButtonPressed"]
    pub fn GetGamepadButtonPressed() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetGamepadAxisCount"]
    pub fn GetGamepadAxisCount(gamepad: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetGamepadAxisMovement"]
    pub fn GetGamepadAxisMovement(
        gamepad: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> f32;
}
extern "C" {
    #[link_name = "IsMouseButtonPressed"]
    pub fn IsMouseButtonPressed(button: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "IsMouseButtonDown"]
    pub fn IsMouseButtonDown(button: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "IsMouseButtonReleased"]
    pub fn IsMouseButtonReleased(button: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "IsMouseButtonUp"]
    pub fn IsMouseButtonUp(button: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "GetMouseX"]
    pub fn GetMouseX() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetMouseY"]
    pub fn GetMouseY() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetMousePosition"]
    pub fn GetMousePosition() -> Vector2;
}
extern "C" {
    #[link_name = "SetMousePosition"]
    pub fn SetMousePosition(x: ::std::os::raw::c_int, y: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "SetMouseOffset"]
    pub fn SetMouseOffset(offsetX: ::std::os::raw::c_int, offsetY: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "SetMouseScale"]
    pub fn SetMouseScale(scaleX: f32, scaleY: f32);
}
extern "C" {
    #[link_name = "GetMouseWheelMove"]
    pub fn GetMouseWheelMove() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetTouchX"]
    pub fn GetTouchX() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetTouchY"]
    pub fn GetTouchY() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetTouchPosition"]
    pub fn GetTouchPosition(index: ::std::os::raw::c_int) -> Vector2;
}
extern "C" {
    #[link_name = "SetGesturesEnabled"]
    pub fn SetGesturesEnabled(gestureFlags: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "IsGestureDetected"]
    pub fn IsGestureDetected(gesture: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "GetGestureDetected"]
    pub fn GetGestureDetected() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetTouchPointsCount"]
    pub fn GetTouchPointsCount() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetGestureHoldDuration"]
    pub fn GetGestureHoldDuration() -> f32;
}
extern "C" {
    #[link_name = "GetGestureDragVector"]
    pub fn GetGestureDragVector() -> Vector2;
}
extern "C" {
    #[link_name = "GetGestureDragAngle"]
    pub fn GetGestureDragAngle() -> f32;
}
extern "C" {
    #[link_name = "GetGesturePinchVector"]
    pub fn GetGesturePinchVector() -> Vector2;
}
extern "C" {
    #[link_name = "GetGesturePinchAngle"]
    pub fn GetGesturePinchAngle() -> f32;
}
extern "C" {
    #[link_name = "SetCameraMode"]
    pub fn SetCameraMode(camera: Camera3D, mode: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "UpdateCamera"]
    pub fn UpdateCamera(camera: *mut Camera3D);
}
extern "C" {
    #[link_name = "SetCameraPanControl"]
    pub fn SetCameraPanControl(panKey: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "SetCameraAltControl"]
    pub fn SetCameraAltControl(altKey: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "SetCameraSmoothZoomControl"]
    pub fn SetCameraSmoothZoomControl(szKey: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "SetCameraMoveControls"]
    pub fn SetCameraMoveControls(
        frontKey: ::std::os::raw::c_int,
        backKey: ::std::os::raw::c_int,
        rightKey: ::std::os::raw::c_int,
        leftKey: ::std::os::raw::c_int,
        upKey: ::std::os::raw::c_int,
        downKey: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "DrawPixel"]
    pub fn DrawPixel(posX: ::std::os::raw::c_int, posY: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    #[link_name = "DrawPixelV"]
    pub fn DrawPixelV(position: Vector2, color: Color);
}
extern "C" {
    #[link_name = "DrawLine"]
    pub fn DrawLine(
        startPosX: ::std::os::raw::c_int,
        startPosY: ::std::os::raw::c_int,
        endPosX: ::std::os::raw::c_int,
        endPosY: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawLineV"]
    pub fn DrawLineV(startPos: Vector2, endPos: Vector2, color: Color);
}
extern "C" {
    #[link_name = "DrawLineEx"]
    pub fn DrawLineEx(startPos: Vector2, endPos: Vector2, thick: f32, color: Color);
}
extern "C" {
    #[link_name = "DrawLineBezier"]
    pub fn DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: f32, color: Color);
}
extern "C" {
    #[link_name = "DrawCircle"]
    pub fn DrawCircle(
        centerX: ::std::os::raw::c_int,
        centerY: ::std::os::raw::c_int,
        radius: f32,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawCircleGradient"]
    pub fn DrawCircleGradient(
        centerX: ::std::os::raw::c_int,
        centerY: ::std::os::raw::c_int,
        radius: f32,
        color1: Color,
        color2: Color,
    );
}
extern "C" {
    #[link_name = "DrawCircleV"]
    pub fn DrawCircleV(center: Vector2, radius: f32, color: Color);
}
extern "C" {
    #[link_name = "DrawCircleLines"]
    pub fn DrawCircleLines(
        centerX: ::std::os::raw::c_int,
        centerY: ::std::os::raw::c_int,
        radius: f32,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawRectangle"]
    pub fn DrawRectangle(
        posX: ::std::os::raw::c_int,
        posY: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawRectangleV"]
    pub fn DrawRectangleV(position: Vector2, size: Vector2, color: Color);
}
extern "C" {
    #[link_name = "DrawRectangleRec"]
    pub fn DrawRectangleRec(rec: Rectangle, color: Color);
}
extern "C" {
    #[link_name = "DrawRectanglePro"]
    pub fn DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: f32, color: Color);
}
extern "C" {
    #[link_name = "DrawRectangleGradientV"]
    pub fn DrawRectangleGradientV(
        posX: ::std::os::raw::c_int,
        posY: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color1: Color,
        color2: Color,
    );
}
extern "C" {
    #[link_name = "DrawRectangleGradientH"]
    pub fn DrawRectangleGradientH(
        posX: ::std::os::raw::c_int,
        posY: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color1: Color,
        color2: Color,
    );
}
extern "C" {
    #[link_name = "DrawRectangleGradientEx"]
    pub fn DrawRectangleGradientEx(
        rec: Rectangle,
        col1: Color,
        col2: Color,
        col3: Color,
        col4: Color,
    );
}
extern "C" {
    #[link_name = "DrawRectangleLines"]
    pub fn DrawRectangleLines(
        posX: ::std::os::raw::c_int,
        posY: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawRectangleLinesEx"]
    pub fn DrawRectangleLinesEx(rec: Rectangle, lineThick: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    #[link_name = "DrawTriangle"]
    pub fn DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
}
extern "C" {
    #[link_name = "DrawTriangleLines"]
    pub fn DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color);
}
extern "C" {
    #[link_name = "DrawPoly"]
    pub fn DrawPoly(
        center: Vector2,
        sides: ::std::os::raw::c_int,
        radius: f32,
        rotation: f32,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawPolyEx"]
    pub fn DrawPolyEx(points: *mut Vector2, numPoints: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    #[link_name = "DrawPolyExLines"]
    pub fn DrawPolyExLines(points: *mut Vector2, numPoints: ::std::os::raw::c_int, color: Color);
}
extern "C" {
    #[link_name = "SetShapesTexture"]
    pub fn SetShapesTexture(texture: Texture2D, source: Rectangle);
}
extern "C" {
    #[link_name = "CheckCollisionRecs"]
    pub fn CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle) -> bool;
}
extern "C" {
    #[link_name = "CheckCollisionCircles"]
    pub fn CheckCollisionCircles(
        center1: Vector2,
        radius1: f32,
        center2: Vector2,
        radius2: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "CheckCollisionCircleRec"]
    pub fn CheckCollisionCircleRec(center: Vector2, radius: f32, rec: Rectangle) -> bool;
}
extern "C" {
    #[link_name = "GetCollisionRec"]
    pub fn GetCollisionRec(rec1: Rectangle, rec2: Rectangle) -> Rectangle;
}
extern "C" {
    #[link_name = "CheckCollisionPointRec"]
    pub fn CheckCollisionPointRec(point: Vector2, rec: Rectangle) -> bool;
}
extern "C" {
    #[link_name = "CheckCollisionPointCircle"]
    pub fn CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: f32) -> bool;
}
extern "C" {
    #[link_name = "CheckCollisionPointTriangle"]
    pub fn CheckCollisionPointTriangle(
        point: Vector2,
        p1: Vector2,
        p2: Vector2,
        p3: Vector2,
    ) -> bool;
}
extern "C" {
    #[link_name = "LoadImage"]
    pub fn LoadImage(fileName: *const ::std::os::raw::c_char) -> Image;
}
extern "C" {
    #[link_name = "LoadImageEx"]
    pub fn LoadImageEx(
        pixels: *mut Color,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> Image;
}
extern "C" {
    #[link_name = "LoadImagePro"]
    pub fn LoadImagePro(
        data: *mut ::std::os::raw::c_void,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: ::std::os::raw::c_int,
    ) -> Image;
}
extern "C" {
    #[link_name = "LoadImageRaw"]
    pub fn LoadImageRaw(
        fileName: *const ::std::os::raw::c_char,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: ::std::os::raw::c_int,
        headerSize: ::std::os::raw::c_int,
    ) -> Image;
}
extern "C" {
    #[link_name = "ExportImage"]
    pub fn ExportImage(image: Image, fileName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "ExportImageAsCode"]
    pub fn ExportImageAsCode(image: Image, fileName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "LoadTexture"]
    pub fn LoadTexture(fileName: *const ::std::os::raw::c_char) -> Texture2D;
}
extern "C" {
    #[link_name = "LoadTextureFromImage"]
    pub fn LoadTextureFromImage(image: Image) -> Texture2D;
}
extern "C" {
    #[link_name = "LoadRenderTexture"]
    pub fn LoadRenderTexture(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> RenderTexture2D;
}
extern "C" {
    #[link_name = "UnloadImage"]
    pub fn UnloadImage(image: Image);
}
extern "C" {
    #[link_name = "UnloadTexture"]
    pub fn UnloadTexture(texture: Texture2D);
}
extern "C" {
    #[link_name = "UnloadRenderTexture"]
    pub fn UnloadRenderTexture(target: RenderTexture2D);
}
extern "C" {
    #[link_name = "GetImageData"]
    pub fn GetImageData(image: Image) -> *mut Color;
}
extern "C" {
    #[link_name = "GetImageDataNormalized"]
    pub fn GetImageDataNormalized(image: Image) -> *mut Vector4;
}
extern "C" {
    #[link_name = "GetPixelDataSize"]
    pub fn GetPixelDataSize(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "GetTextureData"]
    pub fn GetTextureData(texture: Texture2D) -> Image;
}
extern "C" {
    #[link_name = "UpdateTexture"]
    pub fn UpdateTexture(texture: Texture2D, pixels: *const ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "ImageCopy"]
    pub fn ImageCopy(image: Image) -> Image;
}
extern "C" {
    #[link_name = "ImageToPOT"]
    pub fn ImageToPOT(image: *mut Image, fillColor: Color);
}
extern "C" {
    #[link_name = "ImageFormat"]
    pub fn ImageFormat(image: *mut Image, newFormat: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "ImageAlphaMask"]
    pub fn ImageAlphaMask(image: *mut Image, alphaMask: Image);
}
extern "C" {
    #[link_name = "ImageAlphaClear"]
    pub fn ImageAlphaClear(image: *mut Image, color: Color, threshold: f32);
}
extern "C" {
    #[link_name = "ImageAlphaCrop"]
    pub fn ImageAlphaCrop(image: *mut Image, threshold: f32);
}
extern "C" {
    #[link_name = "ImageAlphaPremultiply"]
    pub fn ImageAlphaPremultiply(image: *mut Image);
}
extern "C" {
    #[link_name = "ImageCrop"]
    pub fn ImageCrop(image: *mut Image, crop: Rectangle);
}
extern "C" {
    #[link_name = "ImageResize"]
    pub fn ImageResize(
        image: *mut Image,
        newWidth: ::std::os::raw::c_int,
        newHeight: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "ImageResizeNN"]
    pub fn ImageResizeNN(
        image: *mut Image,
        newWidth: ::std::os::raw::c_int,
        newHeight: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "ImageResizeCanvas"]
    pub fn ImageResizeCanvas(
        image: *mut Image,
        newWidth: ::std::os::raw::c_int,
        newHeight: ::std::os::raw::c_int,
        offsetX: ::std::os::raw::c_int,
        offsetY: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "ImageMipmaps"]
    pub fn ImageMipmaps(image: *mut Image);
}
extern "C" {
    #[link_name = "ImageDither"]
    pub fn ImageDither(
        image: *mut Image,
        rBpp: ::std::os::raw::c_int,
        gBpp: ::std::os::raw::c_int,
        bBpp: ::std::os::raw::c_int,
        aBpp: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "ImageExtractPalette"]
    pub fn ImageExtractPalette(
        image: Image,
        maxPaletteSize: ::std::os::raw::c_int,
        extractCount: *mut ::std::os::raw::c_int,
    ) -> *mut Color;
}
extern "C" {
    #[link_name = "ImageText"]
    pub fn ImageText(
        text: *const ::std::os::raw::c_char,
        fontSize: ::std::os::raw::c_int,
        color: Color,
    ) -> Image;
}
extern "C" {
    #[link_name = "ImageTextEx"]
    pub fn ImageTextEx(
        font: Font,
        text: *const ::std::os::raw::c_char,
        fontSize: f32,
        spacing: f32,
        tint: Color,
    ) -> Image;
}
extern "C" {
    #[link_name = "ImageDraw"]
    pub fn ImageDraw(dst: *mut Image, src: Image, srcRec: Rectangle, dstRec: Rectangle);
}
extern "C" {
    #[link_name = "ImageDrawRectangle"]
    pub fn ImageDrawRectangle(dst: *mut Image, rec: Rectangle, color: Color);
}
extern "C" {
    #[link_name = "ImageDrawRectangleLines"]
    pub fn ImageDrawRectangleLines(
        dst: *mut Image,
        rec: Rectangle,
        thick: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "ImageDrawText"]
    pub fn ImageDrawText(
        dst: *mut Image,
        position: Vector2,
        text: *const ::std::os::raw::c_char,
        fontSize: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "ImageDrawTextEx"]
    pub fn ImageDrawTextEx(
        dst: *mut Image,
        position: Vector2,
        font: Font,
        text: *const ::std::os::raw::c_char,
        fontSize: f32,
        spacing: f32,
        color: Color,
    );
}
extern "C" {
    #[link_name = "ImageFlipVertical"]
    pub fn ImageFlipVertical(image: *mut Image);
}
extern "C" {
    #[link_name = "ImageFlipHorizontal"]
    pub fn ImageFlipHorizontal(image: *mut Image);
}
extern "C" {
    #[link_name = "ImageRotateCW"]
    pub fn ImageRotateCW(image: *mut Image);
}
extern "C" {
    #[link_name = "ImageRotateCCW"]
    pub fn ImageRotateCCW(image: *mut Image);
}
extern "C" {
    #[link_name = "ImageColorTint"]
    pub fn ImageColorTint(image: *mut Image, color: Color);
}
extern "C" {
    #[link_name = "ImageColorInvert"]
    pub fn ImageColorInvert(image: *mut Image);
}
extern "C" {
    #[link_name = "ImageColorGrayscale"]
    pub fn ImageColorGrayscale(image: *mut Image);
}
extern "C" {
    #[link_name = "ImageColorContrast"]
    pub fn ImageColorContrast(image: *mut Image, contrast: f32);
}
extern "C" {
    #[link_name = "ImageColorBrightness"]
    pub fn ImageColorBrightness(image: *mut Image, brightness: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "ImageColorReplace"]
    pub fn ImageColorReplace(image: *mut Image, color: Color, replace: Color);
}
extern "C" {
    #[link_name = "GenImageColor"]
    pub fn GenImageColor(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color: Color,
    ) -> Image;
}
extern "C" {
    #[link_name = "GenImageGradientV"]
    pub fn GenImageGradientV(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        top: Color,
        bottom: Color,
    ) -> Image;
}
extern "C" {
    #[link_name = "GenImageGradientH"]
    pub fn GenImageGradientH(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        left: Color,
        right: Color,
    ) -> Image;
}
extern "C" {
    #[link_name = "GenImageGradientRadial"]
    pub fn GenImageGradientRadial(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        density: f32,
        inner: Color,
        outer: Color,
    ) -> Image;
}
extern "C" {
    #[link_name = "GenImageChecked"]
    pub fn GenImageChecked(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        checksX: ::std::os::raw::c_int,
        checksY: ::std::os::raw::c_int,
        col1: Color,
        col2: Color,
    ) -> Image;
}
extern "C" {
    #[link_name = "GenImageWhiteNoise"]
    pub fn GenImageWhiteNoise(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        factor: f32,
    ) -> Image;
}
extern "C" {
    #[link_name = "GenImagePerlinNoise"]
    pub fn GenImagePerlinNoise(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        offsetX: ::std::os::raw::c_int,
        offsetY: ::std::os::raw::c_int,
        scale: f32,
    ) -> Image;
}
extern "C" {
    #[link_name = "GenImageCellular"]
    pub fn GenImageCellular(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        tileSize: ::std::os::raw::c_int,
    ) -> Image;
}
extern "C" {
    #[link_name = "GenTextureMipmaps"]
    pub fn GenTextureMipmaps(texture: *mut Texture2D);
}
extern "C" {
    #[link_name = "SetTextureFilter"]
    pub fn SetTextureFilter(texture: Texture2D, filterMode: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "SetTextureWrap"]
    pub fn SetTextureWrap(texture: Texture2D, wrapMode: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "DrawTexture"]
    pub fn DrawTexture(
        texture: Texture2D,
        posX: ::std::os::raw::c_int,
        posY: ::std::os::raw::c_int,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "DrawTextureV"]
    pub fn DrawTextureV(texture: Texture2D, position: Vector2, tint: Color);
}
extern "C" {
    #[link_name = "DrawTextureEx"]
    pub fn DrawTextureEx(
        texture: Texture2D,
        position: Vector2,
        rotation: f32,
        scale: f32,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "DrawTextureRec"]
    pub fn DrawTextureRec(texture: Texture2D, sourceRec: Rectangle, position: Vector2, tint: Color);
}
extern "C" {
    #[link_name = "DrawTextureQuad"]
    pub fn DrawTextureQuad(
        texture: Texture2D,
        tiling: Vector2,
        offset: Vector2,
        quad: Rectangle,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "DrawTexturePro"]
    pub fn DrawTexturePro(
        texture: Texture2D,
        sourceRec: Rectangle,
        destRec: Rectangle,
        origin: Vector2,
        rotation: f32,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "DrawTextureNPatch"]
    pub fn DrawTextureNPatch(
        texture: Texture2D,
        nPatchInfo: NPatchInfo,
        destRec: Rectangle,
        origin: Vector2,
        rotation: f32,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "GetFontDefault"]
    pub fn GetFontDefault() -> Font;
}
extern "C" {
    #[link_name = "LoadFont"]
    pub fn LoadFont(fileName: *const ::std::os::raw::c_char) -> Font;
}
extern "C" {
    #[link_name = "LoadFontEx"]
    pub fn LoadFontEx(
        fileName: *const ::std::os::raw::c_char,
        fontSize: ::std::os::raw::c_int,
        fontChars: *mut ::std::os::raw::c_int,
        charsCount: ::std::os::raw::c_int,
    ) -> Font;
}
extern "C" {
    #[link_name = "LoadFontFromImage"]
    pub fn LoadFontFromImage(image: Image, key: Color, firstChar: ::std::os::raw::c_int) -> Font;
}
extern "C" {
    #[link_name = "LoadFontData"]
    pub fn LoadFontData(
        fileName: *const ::std::os::raw::c_char,
        fontSize: ::std::os::raw::c_int,
        fontChars: *mut ::std::os::raw::c_int,
        charsCount: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
    ) -> *mut CharInfo;
}
extern "C" {
    #[link_name = "GenImageFontAtlas"]
    pub fn GenImageFontAtlas(
        chars: *mut CharInfo,
        charsCount: ::std::os::raw::c_int,
        fontSize: ::std::os::raw::c_int,
        padding: ::std::os::raw::c_int,
        packMethod: ::std::os::raw::c_int,
    ) -> Image;
}
extern "C" {
    #[link_name = "UnloadFont"]
    pub fn UnloadFont(font: Font);
}
extern "C" {
    #[link_name = "DrawFPS"]
    pub fn DrawFPS(posX: ::std::os::raw::c_int, posY: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "DrawText"]
    pub fn DrawText(
        text: *const ::std::os::raw::c_char,
        posX: ::std::os::raw::c_int,
        posY: ::std::os::raw::c_int,
        fontSize: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawTextEx"]
    pub fn DrawTextEx(
        font: Font,
        text: *const ::std::os::raw::c_char,
        position: Vector2,
        fontSize: f32,
        spacing: f32,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "DrawTextRec"]
    pub fn DrawTextRec(
        font: Font,
        text: *const ::std::os::raw::c_char,
        rec: Rectangle,
        fontSize: f32,
        spacing: f32,
        wordWrap: bool,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "MeasureText"]
    pub fn MeasureText(
        text: *const ::std::os::raw::c_char,
        fontSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "MeasureTextEx"]
    pub fn MeasureTextEx(
        font: Font,
        text: *const ::std::os::raw::c_char,
        fontSize: f32,
        spacing: f32,
    ) -> Vector2;
}
extern "C" {
    #[link_name = "GetGlyphIndex"]
    pub fn GetGlyphIndex(font: Font, character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "TextIsEqual"]
    pub fn TextIsEqual(
        text1: *const ::std::os::raw::c_char,
        text2: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "TextLength"]
    pub fn TextLength(text: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "TextFormat"]
    pub fn TextFormat(text: *const ::std::os::raw::c_char, ...) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "TextSubtext"]
    pub fn TextSubtext(
        text: *const ::std::os::raw::c_char,
        position: ::std::os::raw::c_int,
        length: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "TextReplace"]
    pub fn TextReplace(
        text: *mut ::std::os::raw::c_char,
        replace: *const ::std::os::raw::c_char,
        by: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "TextInsert"]
    pub fn TextInsert(
        text: *const ::std::os::raw::c_char,
        insert: *const ::std::os::raw::c_char,
        position: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "TextJoin"]
    pub fn TextJoin(
        textList: *mut *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        delimiter: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "TextSplit"]
    pub fn TextSplit(
        text: *const ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "TextSplitEx"]
    pub fn TextSplitEx(
        text: *const ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_int,
        ptrs: *mut *const ::std::os::raw::c_char,
        lengths: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "TextAppend"]
    pub fn TextAppend(
        text: *mut ::std::os::raw::c_char,
        append: *const ::std::os::raw::c_char,
        position: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "TextFindIndex"]
    pub fn TextFindIndex(
        text: *const ::std::os::raw::c_char,
        find: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "TextToUpper"]
    pub fn TextToUpper(text: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "TextToLower"]
    pub fn TextToLower(text: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "TextToPascal"]
    pub fn TextToPascal(text: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "DrawLine3D"]
    pub fn DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color);
}
extern "C" {
    #[link_name = "DrawCircle3D"]
    pub fn DrawCircle3D(
        center: Vector3,
        radius: f32,
        rotationAxis: Vector3,
        rotationAngle: f32,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawCube"]
    pub fn DrawCube(position: Vector3, width: f32, height: f32, length: f32, color: Color);
}
extern "C" {
    #[link_name = "DrawCubeV"]
    pub fn DrawCubeV(position: Vector3, size: Vector3, color: Color);
}
extern "C" {
    #[link_name = "DrawCubeWires"]
    pub fn DrawCubeWires(position: Vector3, width: f32, height: f32, length: f32, color: Color);
}
extern "C" {
    #[link_name = "DrawCubeTexture"]
    pub fn DrawCubeTexture(
        texture: Texture2D,
        position: Vector3,
        width: f32,
        height: f32,
        length: f32,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawSphere"]
    pub fn DrawSphere(centerPos: Vector3, radius: f32, color: Color);
}
extern "C" {
    #[link_name = "DrawSphereEx"]
    pub fn DrawSphereEx(
        centerPos: Vector3,
        radius: f32,
        rings: ::std::os::raw::c_int,
        slices: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawSphereWires"]
    pub fn DrawSphereWires(
        centerPos: Vector3,
        radius: f32,
        rings: ::std::os::raw::c_int,
        slices: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawCylinder"]
    pub fn DrawCylinder(
        position: Vector3,
        radiusTop: f32,
        radiusBottom: f32,
        height: f32,
        slices: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawCylinderWires"]
    pub fn DrawCylinderWires(
        position: Vector3,
        radiusTop: f32,
        radiusBottom: f32,
        height: f32,
        slices: ::std::os::raw::c_int,
        color: Color,
    );
}
extern "C" {
    #[link_name = "DrawPlane"]
    pub fn DrawPlane(centerPos: Vector3, size: Vector2, color: Color);
}
extern "C" {
    #[link_name = "DrawRay"]
    pub fn DrawRay(ray: Ray, color: Color);
}
extern "C" {
    #[link_name = "DrawGrid"]
    pub fn DrawGrid(slices: ::std::os::raw::c_int, spacing: f32);
}
extern "C" {
    #[link_name = "DrawGizmo"]
    pub fn DrawGizmo(position: Vector3);
}
extern "C" {
    #[link_name = "LoadModel"]
    pub fn LoadModel(fileName: *const ::std::os::raw::c_char) -> Model;
}
extern "C" {
    #[link_name = "LoadModelFromMesh"]
    pub fn LoadModelFromMesh(mesh: Mesh) -> Model;
}
extern "C" {
    #[link_name = "UnloadModel"]
    pub fn UnloadModel(model: Model);
}
extern "C" {
    #[link_name = "LoadMesh"]
    pub fn LoadMesh(fileName: *const ::std::os::raw::c_char) -> Mesh;
}
extern "C" {
    #[link_name = "UnloadMesh"]
    pub fn UnloadMesh(mesh: *mut Mesh);
}
extern "C" {
    #[link_name = "ExportMesh"]
    pub fn ExportMesh(mesh: Mesh, fileName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "MeshBoundingBox"]
    pub fn MeshBoundingBox(mesh: Mesh) -> BoundingBox;
}
extern "C" {
    #[link_name = "MeshTangents"]
    pub fn MeshTangents(mesh: *mut Mesh);
}
extern "C" {
    #[link_name = "MeshBinormals"]
    pub fn MeshBinormals(mesh: *mut Mesh);
}
extern "C" {
    #[link_name = "GenMeshPoly"]
    pub fn GenMeshPoly(sides: ::std::os::raw::c_int, radius: f32) -> Mesh;
}
extern "C" {
    #[link_name = "GenMeshPlane"]
    pub fn GenMeshPlane(
        width: f32,
        length: f32,
        resX: ::std::os::raw::c_int,
        resZ: ::std::os::raw::c_int,
    ) -> Mesh;
}
extern "C" {
    #[link_name = "GenMeshCube"]
    pub fn GenMeshCube(width: f32, height: f32, length: f32) -> Mesh;
}
extern "C" {
    #[link_name = "GenMeshSphere"]
    pub fn GenMeshSphere(
        radius: f32,
        rings: ::std::os::raw::c_int,
        slices: ::std::os::raw::c_int,
    ) -> Mesh;
}
extern "C" {
    #[link_name = "GenMeshHemiSphere"]
    pub fn GenMeshHemiSphere(
        radius: f32,
        rings: ::std::os::raw::c_int,
        slices: ::std::os::raw::c_int,
    ) -> Mesh;
}
extern "C" {
    #[link_name = "GenMeshCylinder"]
    pub fn GenMeshCylinder(radius: f32, height: f32, slices: ::std::os::raw::c_int) -> Mesh;
}
extern "C" {
    #[link_name = "GenMeshTorus"]
    pub fn GenMeshTorus(
        radius: f32,
        size: f32,
        radSeg: ::std::os::raw::c_int,
        sides: ::std::os::raw::c_int,
    ) -> Mesh;
}
extern "C" {
    #[link_name = "GenMeshKnot"]
    pub fn GenMeshKnot(
        radius: f32,
        size: f32,
        radSeg: ::std::os::raw::c_int,
        sides: ::std::os::raw::c_int,
    ) -> Mesh;
}
extern "C" {
    #[link_name = "GenMeshHeightmap"]
    pub fn GenMeshHeightmap(heightmap: Image, size: Vector3) -> Mesh;
}
extern "C" {
    #[link_name = "GenMeshCubicmap"]
    pub fn GenMeshCubicmap(cubicmap: Image, cubeSize: Vector3) -> Mesh;
}
extern "C" {
    #[link_name = "LoadMaterial"]
    pub fn LoadMaterial(fileName: *const ::std::os::raw::c_char) -> Material;
}
extern "C" {
    #[link_name = "LoadMaterialDefault"]
    pub fn LoadMaterialDefault() -> Material;
}
extern "C" {
    #[link_name = "UnloadMaterial"]
    pub fn UnloadMaterial(material: Material);
}
extern "C" {
    #[link_name = "DrawModel"]
    pub fn DrawModel(model: Model, position: Vector3, scale: f32, tint: Color);
}
extern "C" {
    #[link_name = "DrawModelEx"]
    pub fn DrawModelEx(
        model: Model,
        position: Vector3,
        rotationAxis: Vector3,
        rotationAngle: f32,
        scale: Vector3,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "DrawModelWires"]
    pub fn DrawModelWires(model: Model, position: Vector3, scale: f32, tint: Color);
}
extern "C" {
    #[link_name = "DrawModelWiresEx"]
    pub fn DrawModelWiresEx(
        model: Model,
        position: Vector3,
        rotationAxis: Vector3,
        rotationAngle: f32,
        scale: Vector3,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "DrawBoundingBox"]
    pub fn DrawBoundingBox(box_: BoundingBox, color: Color);
}
extern "C" {
    #[link_name = "DrawBillboard"]
    pub fn DrawBillboard(
        camera: Camera3D,
        texture: Texture2D,
        center: Vector3,
        size: f32,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "DrawBillboardRec"]
    pub fn DrawBillboardRec(
        camera: Camera3D,
        texture: Texture2D,
        sourceRec: Rectangle,
        center: Vector3,
        size: f32,
        tint: Color,
    );
}
extern "C" {
    #[link_name = "CheckCollisionSpheres"]
    pub fn CheckCollisionSpheres(
        centerA: Vector3,
        radiusA: f32,
        centerB: Vector3,
        radiusB: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "CheckCollisionBoxes"]
    pub fn CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox) -> bool;
}
extern "C" {
    #[link_name = "CheckCollisionBoxSphere"]
    pub fn CheckCollisionBoxSphere(
        box_: BoundingBox,
        centerSphere: Vector3,
        radiusSphere: f32,
    ) -> bool;
}
extern "C" {
    #[link_name = "CheckCollisionRaySphere"]
    pub fn CheckCollisionRaySphere(ray: Ray, spherePosition: Vector3, sphereRadius: f32) -> bool;
}
extern "C" {
    #[link_name = "CheckCollisionRaySphereEx"]
    pub fn CheckCollisionRaySphereEx(
        ray: Ray,
        spherePosition: Vector3,
        sphereRadius: f32,
        collisionPoint: *mut Vector3,
    ) -> bool;
}
extern "C" {
    #[link_name = "CheckCollisionRayBox"]
    pub fn CheckCollisionRayBox(ray: Ray, box_: BoundingBox) -> bool;
}
extern "C" {
    #[link_name = "GetCollisionRayModel"]
    pub fn GetCollisionRayModel(ray: Ray, model: *mut Model) -> RayHitInfo;
}
extern "C" {
    #[link_name = "GetCollisionRayTriangle"]
    pub fn GetCollisionRayTriangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayHitInfo;
}
extern "C" {
    #[link_name = "GetCollisionRayGround"]
    pub fn GetCollisionRayGround(ray: Ray, groundHeight: f32) -> RayHitInfo;
}
extern "C" {
    #[link_name = "LoadText"]
    pub fn LoadText(fileName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "LoadShader"]
    pub fn LoadShader(
        vsFileName: *const ::std::os::raw::c_char,
        fsFileName: *const ::std::os::raw::c_char,
    ) -> Shader;
}
extern "C" {
    #[link_name = "LoadShaderCode"]
    pub fn LoadShaderCode(
        vsCode: *mut ::std::os::raw::c_char,
        fsCode: *mut ::std::os::raw::c_char,
    ) -> Shader;
}
extern "C" {
    #[link_name = "UnloadShader"]
    pub fn UnloadShader(shader: Shader);
}
extern "C" {
    #[link_name = "GetShaderDefault"]
    pub fn GetShaderDefault() -> Shader;
}
extern "C" {
    #[link_name = "GetTextureDefault"]
    pub fn GetTextureDefault() -> Texture2D;
}
extern "C" {
    #[link_name = "GetShaderLocation"]
    pub fn GetShaderLocation(
        shader: Shader,
        uniformName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "SetShaderValue"]
    pub fn SetShaderValue(
        shader: Shader,
        uniformLoc: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_void,
        uniformType: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "SetShaderValueV"]
    pub fn SetShaderValueV(
        shader: Shader,
        uniformLoc: ::std::os::raw::c_int,
        value: *const ::std::os::raw::c_void,
        uniformType: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "SetShaderValueMatrix"]
    pub fn SetShaderValueMatrix(shader: Shader, uniformLoc: ::std::os::raw::c_int, mat: Matrix);
}
extern "C" {
    #[link_name = "SetMatrixProjection"]
    pub fn SetMatrixProjection(proj: Matrix);
}
extern "C" {
    #[link_name = "SetMatrixModelview"]
    pub fn SetMatrixModelview(view: Matrix);
}
extern "C" {
    #[link_name = "GetMatrixModelview"]
    pub fn GetMatrixModelview() -> Matrix;
}
extern "C" {
    #[link_name = "GenTextureCubemap"]
    pub fn GenTextureCubemap(
        shader: Shader,
        skyHDR: Texture2D,
        size: ::std::os::raw::c_int,
    ) -> Texture2D;
}
extern "C" {
    #[link_name = "GenTextureIrradiance"]
    pub fn GenTextureIrradiance(
        shader: Shader,
        cubemap: Texture2D,
        size: ::std::os::raw::c_int,
    ) -> Texture2D;
}
extern "C" {
    #[link_name = "GenTexturePrefilter"]
    pub fn GenTexturePrefilter(
        shader: Shader,
        cubemap: Texture2D,
        size: ::std::os::raw::c_int,
    ) -> Texture2D;
}
extern "C" {
    #[link_name = "GenTextureBRDF"]
    pub fn GenTextureBRDF(shader: Shader, size: ::std::os::raw::c_int) -> Texture2D;
}
extern "C" {
    #[link_name = "BeginShaderMode"]
    pub fn BeginShaderMode(shader: Shader);
}
extern "C" {
    #[link_name = "EndShaderMode"]
    pub fn EndShaderMode();
}
extern "C" {
    #[link_name = "BeginBlendMode"]
    pub fn BeginBlendMode(mode: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "EndBlendMode"]
    pub fn EndBlendMode();
}
extern "C" {
    #[link_name = "BeginScissorMode"]
    pub fn BeginScissorMode(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "EndScissorMode"]
    pub fn EndScissorMode();
}
extern "C" {
    #[link_name = "GetVrDeviceInfo"]
    pub fn GetVrDeviceInfo(vrDeviceType: ::std::os::raw::c_int) -> VrDeviceInfo;
}
extern "C" {
    #[link_name = "InitVrSimulator"]
    pub fn InitVrSimulator(info: VrDeviceInfo);
}
extern "C" {
    #[link_name = "CloseVrSimulator"]
    pub fn CloseVrSimulator();
}
extern "C" {
    #[link_name = "IsVrSimulatorReady"]
    pub fn IsVrSimulatorReady() -> bool;
}
extern "C" {
    #[link_name = "SetVrDistortionShader"]
    pub fn SetVrDistortionShader(shader: Shader);
}
extern "C" {
    #[link_name = "UpdateVrTracking"]
    pub fn UpdateVrTracking(camera: *mut Camera3D);
}
extern "C" {
    #[link_name = "ToggleVrMode"]
    pub fn ToggleVrMode();
}
extern "C" {
    #[link_name = "BeginVrDrawing"]
    pub fn BeginVrDrawing();
}
extern "C" {
    #[link_name = "EndVrDrawing"]
    pub fn EndVrDrawing();
}
extern "C" {
    #[link_name = "InitAudioDevice"]
    pub fn InitAudioDevice();
}
extern "C" {
    #[link_name = "CloseAudioDevice"]
    pub fn CloseAudioDevice();
}
extern "C" {
    #[link_name = "IsAudioDeviceReady"]
    pub fn IsAudioDeviceReady() -> bool;
}
extern "C" {
    #[link_name = "SetMasterVolume"]
    pub fn SetMasterVolume(volume: f32);
}
extern "C" {
    #[link_name = "LoadWave"]
    pub fn LoadWave(fileName: *const ::std::os::raw::c_char) -> Wave;
}
extern "C" {
    #[link_name = "LoadWaveEx"]
    pub fn LoadWaveEx(
        data: *mut ::std::os::raw::c_void,
        sampleCount: ::std::os::raw::c_int,
        sampleRate: ::std::os::raw::c_int,
        sampleSize: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
    ) -> Wave;
}
extern "C" {
    #[link_name = "LoadSound"]
    pub fn LoadSound(fileName: *const ::std::os::raw::c_char) -> Sound;
}
extern "C" {
    #[link_name = "LoadSoundFromWave"]
    pub fn LoadSoundFromWave(wave: Wave) -> Sound;
}
extern "C" {
    #[link_name = "UpdateSound"]
    pub fn UpdateSound(
        sound: Sound,
        data: *const ::std::os::raw::c_void,
        samplesCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "UnloadWave"]
    pub fn UnloadWave(wave: Wave);
}
extern "C" {
    #[link_name = "UnloadSound"]
    pub fn UnloadSound(sound: Sound);
}
extern "C" {
    #[link_name = "ExportWave"]
    pub fn ExportWave(wave: Wave, fileName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "ExportWaveAsCode"]
    pub fn ExportWaveAsCode(wave: Wave, fileName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "PlaySound"]
    pub fn PlaySound(sound: Sound);
}
extern "C" {
    #[link_name = "PauseSound"]
    pub fn PauseSound(sound: Sound);
}
extern "C" {
    #[link_name = "ResumeSound"]
    pub fn ResumeSound(sound: Sound);
}
extern "C" {
    #[link_name = "StopSound"]
    pub fn StopSound(sound: Sound);
}
extern "C" {
    #[link_name = "IsSoundPlaying"]
    pub fn IsSoundPlaying(sound: Sound) -> bool;
}
extern "C" {
    #[link_name = "SetSoundVolume"]
    pub fn SetSoundVolume(sound: Sound, volume: f32);
}
extern "C" {
    #[link_name = "SetSoundPitch"]
    pub fn SetSoundPitch(sound: Sound, pitch: f32);
}
extern "C" {
    #[link_name = "WaveFormat"]
    pub fn WaveFormat(
        wave: *mut Wave,
        sampleRate: ::std::os::raw::c_int,
        sampleSize: ::std::os::raw::c_int,
        channels: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "WaveCopy"]
    pub fn WaveCopy(wave: Wave) -> Wave;
}
extern "C" {
    #[link_name = "WaveCrop"]
    pub fn WaveCrop(
        wave: *mut Wave,
        initSample: ::std::os::raw::c_int,
        finalSample: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "GetWaveData"]
    pub fn GetWaveData(wave: Wave) -> *mut f32;
}
extern "C" {
    #[link_name = "LoadMusicStream"]
    pub fn LoadMusicStream(fileName: *const ::std::os::raw::c_char) -> Music;
}
extern "C" {
    #[link_name = "UnloadMusicStream"]
    pub fn UnloadMusicStream(music: Music);
}
extern "C" {
    #[link_name = "PlayMusicStream"]
    pub fn PlayMusicStream(music: Music);
}
extern "C" {
    #[link_name = "UpdateMusicStream"]
    pub fn UpdateMusicStream(music: Music);
}
extern "C" {
    #[link_name = "StopMusicStream"]
    pub fn StopMusicStream(music: Music);
}
extern "C" {
    #[link_name = "PauseMusicStream"]
    pub fn PauseMusicStream(music: Music);
}
extern "C" {
    #[link_name = "ResumeMusicStream"]
    pub fn ResumeMusicStream(music: Music);
}
extern "C" {
    #[link_name = "IsMusicPlaying"]
    pub fn IsMusicPlaying(music: Music) -> bool;
}
extern "C" {
    #[link_name = "SetMusicVolume"]
    pub fn SetMusicVolume(music: Music, volume: f32);
}
extern "C" {
    #[link_name = "SetMusicPitch"]
    pub fn SetMusicPitch(music: Music, pitch: f32);
}
extern "C" {
    #[link_name = "SetMusicLoopCount"]
    pub fn SetMusicLoopCount(music: Music, count: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "GetMusicTimeLength"]
    pub fn GetMusicTimeLength(music: Music) -> f32;
}
extern "C" {
    #[link_name = "GetMusicTimePlayed"]
    pub fn GetMusicTimePlayed(music: Music) -> f32;
}
extern "C" {
    #[link_name = "InitAudioStream"]
    pub fn InitAudioStream(
        sampleRate: ::std::os::raw::c_uint,
        sampleSize: ::std::os::raw::c_uint,
        channels: ::std::os::raw::c_uint,
    ) -> AudioStream;
}
extern "C" {
    #[link_name = "UpdateAudioStream"]
    pub fn UpdateAudioStream(
        stream: AudioStream,
        data: *const ::std::os::raw::c_void,
        samplesCount: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "CloseAudioStream"]
    pub fn CloseAudioStream(stream: AudioStream);
}
extern "C" {
    #[link_name = "IsAudioBufferProcessed"]
    pub fn IsAudioBufferProcessed(stream: AudioStream) -> bool;
}
extern "C" {
    #[link_name = "PlayAudioStream"]
    pub fn PlayAudioStream(stream: AudioStream);
}
extern "C" {
    #[link_name = "PauseAudioStream"]
    pub fn PauseAudioStream(stream: AudioStream);
}
extern "C" {
    #[link_name = "ResumeAudioStream"]
    pub fn ResumeAudioStream(stream: AudioStream);
}
extern "C" {
    #[link_name = "IsAudioStreamPlaying"]
    pub fn IsAudioStreamPlaying(stream: AudioStream) -> bool;
}
extern "C" {
    #[link_name = "StopAudioStream"]
    pub fn StopAudioStream(stream: AudioStream);
}
extern "C" {
    #[link_name = "SetAudioStreamVolume"]
    pub fn SetAudioStreamVolume(stream: AudioStream, volume: f32);
}
extern "C" {
    #[link_name = "SetAudioStreamPitch"]
    pub fn SetAudioStreamPitch(stream: AudioStream, pitch: f32);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
